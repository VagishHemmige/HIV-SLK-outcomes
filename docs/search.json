[
  {
    "objectID": "quarto/tables.html",
    "href": "quarto/tables.html",
    "title": "Tables",
    "section": "",
    "text": "The code in this script generates tables for the manuscript."
  },
  {
    "objectID": "quarto/tables.html#table-1",
    "href": "quarto/tables.html#table-1",
    "title": "Tables",
    "section": "Table 1",
    "text": "Table 1\nThe following code uses the gt package to create a Table 1 comparing cases and controls on key variables measured at the index date, to assess balance after risk-set matching. The code then saves the tables as .docx and as .png files.\n\n\nCode\n#Create a table of the post-match results to confirm that demographics were appropriately balanced\ntable1&lt;-post_match_results%&gt;%\n  mutate(age=time_length(interval(BORN, index_date_match), \"years\"))%&gt;%\n  dplyr::select(cirrhosis, CMV, HIV, diabetes, cumulative_transplant_total, current_graft_status,\n                liver_transplant, lung_transplant, heart_transplant, heartlung_transplant,\n                pancreas_transplant, intestinal_transplant,\n                age, SEX, RACE, HISPANIC, RACEETH, RURALURBAN, cryptococcus_dx_date, \n         pancreas_transplant, intestinal_transplant, patient_type)%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.png\")\nfile.exists(\"tables/table1_baseline.docx\") && file.remove(\"tables/table1_baseline.docx\")\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.docx\")"
  },
  {
    "objectID": "quarto/tables.html#table-2",
    "href": "quarto/tables.html#table-2",
    "title": "Tables",
    "section": "Table 2",
    "text": "Table 2\nTable 2 lists the International Classification of Diseases (ICD-9 and ICD-10) diagnosis codes used to define baseline comorbidities in the study cohort. Comorbidity definitions were specified a priori in the R/setup.R file and implemented uniformly for cases and matched controls.\nCodes were grouped by clinical condition to reflect common diagnostic categories used in transplant and claims-based research. Both ICD-9 and ICD-10 codes were included to ensure continuity across calendar years spanning the ICD-9–to–ICD-10 transition period. For each comorbidity, all qualifying diagnosis codes are shown explicitly to promote transparency and reproducibility.\nThese comorbidity definitions were used for cohort construction, matching, and covariate adjustment, and were applied using diagnosis information available prior to or at the index date to avoid conditioning on post-exposure information.\nTable 2 is provided as a reference table to facilitate replication of the analytic pipeline and to allow readers to evaluate the clinical face validity of the claims-based comorbidity definitions.\n\n\nCode\n#Table of comorbidities generated from lists created in setup.R, then exported \n\ntable2_icd &lt;- comorbidity_ICD_list%&gt;%\n  imap_dfr(., \n           ~tibble(\n             comorbidity = .y,\n             icd_codes_raw = paste(.x, collapse = \", \")\n             )\n           )%&gt;%\n  gt() %&gt;%\n  cols_label(\n    comorbidity   = \"Comorbidity\",\n    icd_codes_raw = \"ICD Codes\"\n  ) %&gt;%\n  cols_width(\n    comorbidity   ~ px(220),\n    icd_codes_raw ~ px(500)\n  ) %&gt;%\n  tab_options(\n    table.font.size = px(12)\n  )%&gt;%\n  tab_header(\n  title = \"ICD-9 and ICD-10 Codes Used to Define Comorbidities\",\n  subtitle = \"Codes grouped by clinical condition\"\n)\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.png\")\nfile.exists(\"tables/table2_baseline.docx\") && file.remove(\"tables/table2_baseline.docx\")\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.docx\")"
  },
  {
    "objectID": "quarto/tables.html#cost-tables",
    "href": "quarto/tables.html#cost-tables",
    "title": "Tables",
    "section": "Cost tables",
    "text": "Cost tables\nThese tables use the total costs, not the modeled longitudinal costs. Cases and controls are compared. These tables are used for exploration and validation and are not intended for the manuscript.\n\n\nCode\n#Examine costs broken down by type\ncost_broken_down%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\n#Examine costs broken down by type and adjusted for inflation (medians)\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type,\n                         statistic = all_continuous() ~ \"{mean} ({sd})\")%&gt;%\n  add_p()"
  },
  {
    "objectID": "quarto/tables.html#modeled-total-excess-costs",
    "href": "quarto/tables.html#modeled-total-excess-costs",
    "title": "Tables",
    "section": "Modeled total excess costs",
    "text": "Modeled total excess costs\nThis code uses the calculate_total_excess_costs() function in the R/functions.R file to estimate the total excess cost in cases compared with controls. see the functions site for more details about the internal workings of the function.\n\n\nCode\n#Total the grand difference between cases and controls over the entire period of follow up:\ncalculate_total_excess_costs(fit[[\"grand_total_cost_month\"]][[\"gee\"]][[\"linear\"]])"
  },
  {
    "objectID": "quarto/tables.html#other-portions-of-the-analysis",
    "href": "quarto/tables.html#other-portions-of-the-analysis",
    "title": "Tables",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nCreate cohort: Constructs the initial time-varying cohort of kidney transplant recipients, defining cohort entry, follow-up structure, and case/control eligibility prior to matching.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/functions.html",
    "href": "quarto/functions.html",
    "title": "Functions",
    "section": "",
    "text": "The code in this script generates tables for the manuscript."
  },
  {
    "objectID": "quarto/functions.html#plotting-mean-monthly-costs",
    "href": "quarto/functions.html#plotting-mean-monthly-costs",
    "title": "Functions",
    "section": "Plotting mean monthly costs",
    "text": "Plotting mean monthly costs\nThe following function uses ggplot2 to create a plot of monthly costs with a risk table underneath.\nIts inputs are as follows:\n\nfitted_model: the fit object from models created in the R/models.R script\ncountdf: a data frame containing the appropriate count data for cases and controls at each time point, used to create a risk table\n\nThe function uses the emmeans function from the package of the same name to estimate months costs. The x-axis (months) is shifted to the right so that the vertical line at x=0 cleanly separate pre-index and post-index months, and cases and controls are dodged slightly so that the error bars do not overlap.\n\n\nCode\n#Function that returns a ggplot of the mean cost (with confidence interval) for cryptococcus cases and controls by month\nplot_mean_monthly_costs&lt;-function(fitted_model, countdf=final_count_df) {\n\n  #First, use emmeans to calculate the predicted values from the model assuming 30-day months, then convert to data frame\n  emm_df &lt;- emmeans(\n    fitted_model,\n    ~ patient_type | month,\n    at = list(month_offset = 30),\n    type = \"response\"\n  )%&gt;%as.data.frame()%&gt;%\n    \n    #Shifts all points and error_bars 0.5 to the right to avoid the zero-line\n    mutate(month=0.5+as.numeric(month))%&gt;%\n    \n    #Move cases 0.1 to the right and controls 0.1 to the left to improve legibility\n  mutate(month=ifelse(patient_type==\"Case\", month+0.1, month-0.1))%&gt;%\n    mutate(\n      estimate = if (\"response\" %in% names(.)) response else emmean)\n  \n  monthly_plot &lt;- list()\n  \n  # Main plot\n  monthly_plot[[\"main\"]] &lt;- ggplot(data = emm_df) +\n    geom_point(aes(x = month, y = estimate, color = patient_type)) +\n    geom_errorbar(\n      aes(\n        x = month,\n        ymin = asymp.LCL,\n        ymax = asymp.UCL,\n        color = patient_type\n      ),\n      width = 0.1\n    ) +\n    geom_vline(xintercept = 0,\n               linetype = \"dashed\",\n               color = \"gray50\") +\n    theme_classic() +\n    labs(\n      x = \"Month\",\n      y = \"Inflation-adjusted cost per month (dollars)\",\n      color = \"Patient group\"\n    )+\n    theme(legend.position = \"bottom\")\n  \n  # Risk table\n  monthly_plot[[\"risk_table\"]] &lt;- countdf %&gt;%\n    mutate(month = 0.5 + as.numeric(month),\n           y_position = ifelse(patient_type == \"Case\", 0.4, 0.6)) %&gt;%\n    ggplot() +\n    geom_text(\n      aes(x = month, y = y_position, label = n, color=patient_type),\n      size = 3\n    )+\n    coord_cartesian(ylim = c(0.3, 0.7)) +\n    theme_void() +\n    theme(\n      plot.margin = margin(t = -5, b = 5),\n      legend.position = \"none\")\n  \n  # Combine plots\n  monthly_plot[[\"main\"]] /\n    monthly_plot[[\"risk_table\"]] +\n    plot_layout(heights = c(9, 1), guides = \"keep\")+\n    plot_annotation(\n      caption = \"Bottom panel shows N at risk by month\"\n    )\n  \n}"
  },
  {
    "objectID": "quarto/functions.html#calculating-the-number-of-potential-matches",
    "href": "quarto/functions.html#calculating-the-number-of-potential-matches",
    "title": "Functions",
    "section": "Calculating the number of potential matches",
    "text": "Calculating the number of potential matches\nThe above function is passed a control df and a number of values for a case patient, and returns the number of distinct controls which are potential matches. The matching algorithm is hard-coded.\n\n\nCode\n#Function that defines the number of potential control matches for a case\ncalculate_number_potential_matches&lt;-function(control_df,\n                                             USRDS_ID,\n                                             birthdate,\n                                             cirrhosis_status,\n                                             cmv_status,\n                                             hiv_status,\n                                             diabetes_status,\n                                             matching_date,\n                                             matching_days_since_transplant) {\n  \n  print(paste0(\"Calculating number of potential controls for patient: \", USRDS_ID))\n  control_df%&gt;%\n    \n    #Exact match on cirrhosis, CMV, HIV, and diabetes status\n    filter(cirrhosis==cirrhosis_status)%&gt;%\n    #  filter(CMV==cmv_status)%&gt;%\n    filter(HIV==hiv_status)%&gt;%\n    filter(diabetes==diabetes_status)%&gt;%\n    \n    #Risk set matching\n    filter(tstart&lt;=matching_days_since_transplant)%&gt;%\n    filter(tstop&gt;matching_days_since_transplant)%&gt;%\n    \n    #Calculate date for age calculations/etc.\n    mutate(.baseline_control_date=matching_days_since_transplant+most_recent_transplant_date)%&gt;%\n    \n    #Make sure case and control are sampled within 3 years of each other\n    filter(abs(time_length(interval(.baseline_control_date, matching_date), \"years\")) &lt;=3)%&gt;%\n    \n    #Date matching\n    #  filter(cohort_start_date&lt;=matching_date)%&gt;%\n    #  filter(cohort_stop_date&gt;matching_date)%&gt;%\n    \n    #Age&gt;=18 on index date\n    filter(time_length(interval(BORN, .baseline_control_date), \"years\") &gt;= 18)%&gt;%\n    \n    #Age difference under 10 years, calculated at sampling date\n    filter(abs(time_length(interval(BORN,.baseline_control_date), \"years\")-\n                 time_length(interval(birthdate,matching_date), \"years\")) &lt;=10)%&gt;%\n    \n    #Confirming 365 day Medicare lookback available for potential match\n    verify_medicare_primary(index_date = matching_date, medicare_coverage_df = medicare_history, cache=TRUE)%&gt;%\n    filter(medicare_primary_TF==TRUE)%&gt;%\n    \n    #Count rows after ensuring controls with mult transplants are only counted once \n    distinct(USRDS_ID)%&gt;%\n    nrow()%&gt;%\n    return()\n  \n}"
  },
  {
    "objectID": "quarto/functions.html#total-excess-costs",
    "href": "quarto/functions.html#total-excess-costs",
    "title": "Functions",
    "section": "Total excess costs",
    "text": "Total excess costs\nThis function takes a fit object from a model and calculates the total estimated excess costs and confidence intervals. This object currently only works for models with linear links.\n\n\nCode\n# Calculate total excess costs in a model\ncalculate_total_excess_costs &lt;- function(fitted_model, link = \"linear\") {\n  \n  # Extract coefficients and vcov matrix\n  coef_df &lt;- tidy(fitted_model)\n  vcov_matrix &lt;- vcov(fitted_model)\n  \n  # Get interaction terms\n  interaction_names &lt;- coef_df %&gt;% \n    filter(str_detect(term, \":\")) %&gt;% \n    pull(term)\n  \n  if (link == \"linear\") {\n    # Sum of coefficients\n    sum_estimate &lt;- coef_df %&gt;% \n      filter(term %in% interaction_names) %&gt;% \n      pull(estimate) %&gt;% \n      sum()\n    \n    # Variance of sum\n    sum_variance &lt;- vcov_matrix[interaction_names, interaction_names] %&gt;% \n      sum()\n    \n    # Standard error and CI\n    sum_se &lt;- sqrt(sum_variance)\n    df &lt;- df.residual(fitted_model)\n    \n    tibble(\n      estimate = sum_estimate,\n      std_error = sum_se,\n      conf_low = estimate - qt(0.975, df) * std_error,\n      conf_high = estimate + qt(0.975, df) * std_error,\n      statistic = estimate / std_error,\n      p_value = 2 * pt(-abs(statistic), df)\n    )\n    \n  } else if (link == \"log\") {\n    # Get coefficients for interactions\n    coefs &lt;- coef(fitted_model)[interaction_names]\n    vcov_sub &lt;- vcov_matrix[interaction_names, interaction_names]\n    \n    # Exponentiate each coefficient\n    exp_coefs &lt;- exp(coefs)\n    \n    # Sum of exponentiated coefficients\n    sum_estimate &lt;- sum(exp_coefs)\n    \n    # Delta method for variance\n    # Gradient: derivative of sum(exp(beta)) w.r.t. each beta is exp(beta)\n    gradient &lt;- exp_coefs\n    \n    # Variance using delta method\n    sum_variance &lt;- as.numeric(t(gradient) %*% vcov_sub %*% gradient)\n    sum_se &lt;- sqrt(sum_variance)\n    \n    # CI using normal approximation (GLM)\n    tibble(\n      estimate = sum_estimate,\n      std_error = sum_se,\n      conf_low = estimate - qnorm(0.975) * std_error,\n      conf_high = estimate + qnorm(0.975) * std_error,\n      statistic = estimate / std_error,\n      p_value = 2 * pnorm(-abs(statistic))\n    )\n    \n  } else {\n    stop(\"link must be either 'linear' or 'log'\")\n  }\n}"
  },
  {
    "objectID": "quarto/functions.html#other-portions-of-the-analysis",
    "href": "quarto/functions.html#other-portions-of-the-analysis",
    "title": "Functions",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nCreate cohort: Constructs the initial time-varying cohort of kidney transplant recipients, defining cohort entry, follow-up structure, and case/control eligibility prior to matching.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/about.html",
    "href": "quarto/about.html",
    "title": "About",
    "section": "",
    "text": "Pending"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "HIV SLK"
  },
  {
    "objectID": "index.html#clinical-background",
    "href": "index.html#clinical-background",
    "title": "Overview",
    "section": "",
    "text": "HIV SLK"
  },
  {
    "objectID": "index.html#what-this-analysis-does",
    "href": "index.html#what-this-analysis-does",
    "title": "Overview",
    "section": "What this analysis does",
    "text": "What this analysis does\nThe goal of HIV SLK outcomes is to compared the outcomes of people living with HIV (PLWH) who have undergone simultaneous liver-kidney transplant to controls without HIV using the Scientific Registry of Transplant Recipients database."
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "Overview",
    "section": "Methods",
    "text": "Methods\nMatching"
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "Overview",
    "section": "Results",
    "text": "Results\nPending"
  },
  {
    "objectID": "index.html#site-navigation",
    "href": "index.html#site-navigation",
    "title": "Overview",
    "section": "Site navigation",
    "text": "Site navigation\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nAbout: methods, assumptions, and disclosures\n\n\nReproducibility\nAll analyses presented on this website are fully reproducible.\nThe complete source code used to perform the full analysis and generate the tables and figures is publicly available at this GitHub repo. The R script R/main.R will run the R subscripts needed for this analysis in the order they are to be run. Model assumptions, parameter values, and analytic workflows are documented in the repository to facilitate transparency and reuse."
  },
  {
    "objectID": "index.html#abstractsmanuscripts",
    "href": "index.html#abstractsmanuscripts",
    "title": "Overview",
    "section": "Abstracts/manuscripts",
    "text": "Abstracts/manuscripts\nThis analysis has yet to be published to date. However, preliminary results have been presented at the NY-NJ Center for AIDS Research 2026 regional conference as a poster.\n\n\n\nPoster preview\n\n\nDownload the poster (PowerPoint)\nDownload as PDF"
  },
  {
    "objectID": "quarto/figures.html",
    "href": "quarto/figures.html",
    "title": "Figures",
    "section": "",
    "text": "The code in this script generates figures for the manuscript."
  },
  {
    "objectID": "quarto/figures.html#final-flowchart",
    "href": "quarto/figures.html#final-flowchart",
    "title": "Figures",
    "section": "Final flowchart",
    "text": "Final flowchart\nThe following code uses the flowchart package to create a STROBE flowchart for the study.\n\n\nCode\n#Final STROBE flowchart\npatients_fc_matched%&gt;%\n  fc_draw()%&gt;%\n  fc_export(\"figures/flowchart.svg\",\n            width=20,\n            height=10)"
  },
  {
    "objectID": "quarto/figures.html#beeswarm-plot-of-total-inflated-costs",
    "href": "quarto/figures.html#beeswarm-plot-of-total-inflated-costs",
    "title": "Figures",
    "section": "Beeswarm plot of total inflated costs",
    "text": "Beeswarm plot of total inflated costs\nThe following code uses the ggbeeswarm add-on to ggplot2 to compare cases and controls in terms of total inflated costs post-index. No attempt is made to adjust for censoring or death.\n\n\nCode\n#GGplot that is beeswarm of adjusted total costs\ncost_inflated%&gt;%\n  mutate(IN_CLM_365d_cost_adjusted_total=ifelse(IN_CLM_365d_cost_adjusted_total==0, 1, IN_CLM_365d_cost_adjusted_total))%&gt;%\n  ggplot()+\n  geom_quasirandom(mapping=aes(x=patient_type, y=IN_CLM_365d_cost_adjusted_total), alpha=0.1)+\n  scale_y_log10()+\n  theme_classic()"
  },
  {
    "objectID": "quarto/figures.html#month-by-month-plots",
    "href": "quarto/figures.html#month-by-month-plots",
    "title": "Figures",
    "section": "Month-by-month plots",
    "text": "Month-by-month plots\nIn order to plot monthly costs predicted from the longitudinal models generated in the R/models.R script, we use the plot_mean_monthly_costs() function from the R/functions.R script to create the ggplot objects, and then save as .svg files.\n\n\nCode\n#Loop that plots the different outcomes longitudinally\n\nfor (outcome in c(\"grand_total_cost_month\", \"IN_CLM_month_total\", \"PS_REV_month_total\", \"IN_CLM_month_groupedHomeHealth\",\n                  \"IN_CLM_month_groupedHospice\",\"IN_CLM_month_groupedNonclaimauxiliary\",\"IN_CLM_month_groupedDialysis\",\n                  \"IN_CLM_month_groupedOutpatient\",\"IN_CLM_month_groupedInpatient\",\"IN_CLM_month_groupedSkilledNursingFacility\")){\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"tweedie\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"tweedie.svg\"),\n         width=14,\n         height=7\n         )\n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"linear\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"linear.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"gee\"]][[\"linear\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" gee\", \" \", \"linear.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"log\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"log.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"gee\"]][[\"log\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" gee\", \" \", \"log.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n}"
  },
  {
    "objectID": "quarto/figures.html#other-portions-of-the-analysis",
    "href": "quarto/figures.html#other-portions-of-the-analysis",
    "title": "Figures",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nCreate cohort: Constructs the initial time-varying cohort of kidney transplant recipients, defining cohort entry, follow-up structure, and case/control eligibility prior to matching.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/setup.html",
    "href": "quarto/setup.html",
    "title": "Setup",
    "section": "",
    "text": "The code in this script imports libraries, initializes constants, and performs other such preparatory work for the main analysis."
  },
  {
    "objectID": "quarto/setup.html#libraries",
    "href": "quarto/setup.html#libraries",
    "title": "Setup",
    "section": "Libraries",
    "text": "Libraries\nThe analysis relies on a set of open-source R packages for data management, cohort construction, visualization, and statistical modeling. These libraries were selected based on their stability, community support, and suitability for large-scale longitudinal health data.\n\n\nCode\n# Libraries necessary for the analysis\n\n#File import libraries\nlibrary(haven)\nlibrary(readr)\nlibrary(readxl)\n\n#File export libraries\nlibrary(writexl)\n\n#Data management libraries\nlibrary(tidyverse)\nlibrary(labelled)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(janitor)\nlibrary(purrr)\nlibrary(lubridate)\nlibrary(conflicted)\n\n#Core library for the SRTR\nlibrary(sRtr)\n\n#Flowchart libraries\nlibrary(strobe)\nlibrary(flowchart)\n\n#Statistical modeling libraries\nlibrary(MatchIt)\nlibrary(survival)\nlibrary(MASS)\nlibrary(sandwich)\nlibrary(lmtest)\n\n\n#Table libraries\nlibrary(gtsummary)\nlibrary(gt)\n\n#Plotting libraries\nlibrary(ggplot2)\nlibrary(survminer)\n\n\n#Use the conflicted package to ensure that the select and filter functions are not superseded\nconflict_prefer(\"select\", \"dplyr\")\nconflict_prefer(\"filter\", \"dplyr\")\nconflict_prefer(\"lag\", \"dplyr\")\n\n\nThe table below lists the required packages along with links to their primary documentation.\n\n\n\n\n\n\n\n\nRequired R Packages\n\n\nLibraries used for data processing, visualization, and statistical modeling\n\n\nCategory\nR package\nDocumentation\n\n\n\n\nFile import\nhaven\nCRAN – haven\n\n\nFile import\nreadr\nCRAN – readr\n\n\nFile import\nreadxl\nCRAN – readxl\n\n\nFile export\nwritexl\nCRAN – writexl\n\n\nData management\ntidyverse\ntidyverse.org\n\n\nData management\nlabelled\nCRAN – labelled\n\n\nData management\ndplyr\nCRAN – dplyr\n\n\nData management\ntidyr\nCRAN – tidyr\n\n\nData management\njanitor\nCRAN – janitor\n\n\nData management\npurrr\nCRAN – purrr\n\n\nData management\nlubridate\nlubridate.tidyverse.org\n\n\nData management\nconflicted\nCRAN – conflicted\n\n\nSRTR-specific\nsRtr\nGitHub – sRtr\n\n\nFlowcharting\nstrobe\nGitHub – strobe\n\n\nFlowcharting\nflowchart\nCRAN – flowchart\n\n\nStatistical modeling\nMatchIt\nCRAN – MatchIt\n\n\nStatistical modeling\nsurvival\nCRAN – survival\n\n\nStatistical modeling\nMASS\nCRAN – MASS\n\n\nStatistical modeling\nsandwich\nCRAN – sandwich\n\n\nStatistical modeling\nlmtest\nCRAN – lmtest\n\n\nTables\ngtsummary\ngtsummary documentation\n\n\nTables\ngt\ngt documentation\n\n\nPlotting\nggplot2\nggplot2.tidyverse.org\n\n\nPlotting\nsurvminer\nCRAN – survminer"
  },
  {
    "objectID": "quarto/setup.html#other-portions-of-the-analysis",
    "href": "quarto/setup.html#other-portions-of-the-analysis",
    "title": "Setup",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  }
]